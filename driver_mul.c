#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  LeftCenterEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  LeftAroundEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  RightCenterEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  RightAroundEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           RightWheel,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LeftWheel,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
struct command{
	short LeftMotor;
	short RightMotor;
	short Hand;
	short GL;
	short DT;
	short DP;
	bool RL;
	bool LL;
};
struct state{
	short up;
	short turn;
	short LeftCenPal;
	short LeftAroPal;
	short RightCenPal;
	short RightAroPal;
	int LeftCenCode;
	int LeftAroCode;
	int RightCenCode;
	int RightAroCode;
	short LeftPower;
	short RightPower;
	int Range;
	int HandState;
};
struct Pid
{
	float Kp;
	float Ki;
	float Kd;
	int pValue;
	int iValue;
	int dValue;
	int LastError;
	short out_max;
	short out_min;
};

//global struct
command Command;
state State;
Pid DriverPID;
//


short DataHandling(short data)
{
	int temp = (data*100/127);
	short back;
	if (temp > 0)
	{
		if (temp < 10){temp = 0;}
		else if (temp < 80)
		{
			temp = 5 * (temp - 10) / 7;
			}else{
			temp = (5 * temp) / 2 - 150;
		}
	}
	else
	{
		if (temp > -10){temp = 0;}
		else if (temp > -80)
		{
			temp = 5 * (temp + 10) / 7;
		}else
		{
			temp = (5 * temp) / 2 + 150;
		}

	}
	back = temp*127/100;
	return back;
}


void ReadDriverSensor()
{
	// return Palstance rad/s
	int StartLC,StartLA, StartRC, StartRA;
	StartLC = SensorValue[LeftCenterEncode];
	StartLA = SensorValue[LeftAroundEncode];
	StartRC = SensorValue[RightCenterEncode];
	StartRA = SensorValue[RightAroundEncode];
	wait1Msec(5);
	State.LeftCenCode = SensorValue[LeftCenterEncode];
	State.LeftAroCode = SensorValue[LeftAroundEncode];
	State.RightCenCode = SensorValue[RightCenterEncode];
	State.RightAroCode = SensorValue[RightAroundEncode];
	State.LeftCenPal = (State.LeftCenCode - StartLC) / 5 * 1000;
	State.LeftAroPal = (State.LeftAroCode - StartLC) / 5 * 1000;
	State.RightCenPal = (State.RightCenCode - StartRC) / 5 * 1000;
	State.RightAroPal = (State.RightAroCode - StartRC) / 5 * 1000;
}
int PidOperation( Pid *pPID , int Error)
{
	int P, I, D, Out;
	pPID -> pValue = Error * pPID -> Kp;
	P = pPID->pValue;

	pPID->iValue += pPID -> Ki * Error;
	I = pPID -> iValue;

	pPID->dValue += pPID->Kd * (pPID->LastError - Error);
	D = pPID -> dValue;

	pPID -> LastError = Error;
	Out = P + I +D;
	if (Out < pPID -> out_min) {Out = pPID->out_min;}
	else if (Out > pPID->out_max){Out = pPID -> out_max;}
	return Out;
}

task Do()
{
	while(true)
	{
		if(abs(Command.RightMotor)>20){motor[RightWheel]=Command.RightMotor;}
		else{motor[RightWheel]=0;}
		if(abs(Command.LeftMotor)>20){motor[LeftWheel]=Command.LeftMotor;}
		else{motor[LeftWheel]=0;}
	}
}
task main()
{
	bLCDBacklight = true;
	startTask(Do, kDefaultTaskPriority);
	int Ltar, Rtar;
	int LE, RE;
	short LeftPID,RightPID,up,turn;
	DriverPID.Kp = 1;
	DriverPID.Ki = 1;
	DriverPID.Kd = 1;
	while(true)
	{
		up = DataHandling(vexRT[Ch3]);
		turn = DataHandling(vexRT[Ch1]);
		Ltar= up - turn;
		Rtar= up + turn;
		ReadDriverSensor();
		LE = Ltar - State.LeftAroPal;
		RE = Rtar - State.RightAroPal;
		LeftPID = PidOperation(&DriverPID, LE);
		RightPID = PidOperation(&DriverPID, RE);
		Command.LeftMotor = LeftPID;
		Command.RightMotor = RightPID;
	}
}
