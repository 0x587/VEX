#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LeftFront,     tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port3,           LeftBack,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           RightFront,    tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           RightBack,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "Joysticks.c"
#include "Struct.c"
#include "Motor.c"
//Global Four Driver Motor
DriverMotorValue DriverMotor[4];
///////////////////////////////
task DriverMotorCommand()
{
	float Kp = 0.1;
	float Kd = 0.1;
	//Set Motor Port
	DriverMotor[0].Port = LeftFront;
	DriverMotor[1].Port = LeftBack;
	DriverMotor[2].Port = RightFront;
	DriverMotor[3].Port = RightBack;
	// Set PID Value
	for(short i = 0;i<4;i++)
	{
		DriverMotor[i].Kp = Kp;
		DriverMotor[i].Kd = Kd;
	}
	while(true)
	{
		UpDateTargetSpeed(DriverMotor);
		UpDateSpeed(DriverMotor);//Spend 5ms
		for(short i = 0;i<4;i++)
		{
			short Error = DriverMotor[i].TargetSpeed - DriverMotor[i].Speed;
			DriverMotor[i].dValue += Error;
			motor[DriverMotor[i].Port] += (
											(Error * DriverMotor[i].Kp)
											+ 
											(DriverMotor[i].dValue * DriverMotor[i].Kd)
										);
		}
	}
}
task main()
{
	startTask(DriverMotorCommand, kDefaultTaskPriority);
	waitUntil(false);
}
