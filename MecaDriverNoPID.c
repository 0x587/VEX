#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LeftFront,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           RightFront,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           RightBack,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port5,           LeftBack,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port6,           LeftCenter,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           RightCenter,   tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

short DataHandling(short data)
{
	int temp = (data*100/127);
	short back;
	if (temp > 0)
	{
		if (temp < 10){temp = 0;}
		else if (temp < 80)
		{
			temp = (temp - 10) / 2;
			}else{
			temp = (13 * temp) / 4 - 225;
		}
	}
	else
	{
		if (temp > -10){temp = 0;}
		else if (temp > -80)
		{
			temp = (temp + 10) / 2;
		}else
		{
			temp = (13 * temp) / 4 + 225;
		}

	}
	back = temp*127/100;
	return back;
}

short GetMotorSpeed(tMotor MotorPort)
{
	int StartCode = getMotorEncoder(MotorPort);
	wait1Msec(5);
	short MoveCode = getMotorEncoder(MotorPort)-StartCode;
	return MoveCode * 200 * 60 / 627.2;
}

struct ActionVector
{
	short SpeedLF;
	short SpeedLB;
	short SpeedRF;
	short SpeedRB;
};
ActionVector vTotal;
task GetCommand()
	{
		short Xasis,Yasis,Yaw;
		ActionVector vUpBack, vLeftRight, vTurn;
		while(true)
		{
			Xasis = DataHandling(vexRT[Ch4]);
			Yasis = DataHandling(vexRT[Ch3]);
			Yaw = DataHandling(vexRT[Ch1]);

			// UpBack
			vUpBack.SpeedLF = vUpBack.SpeedLB = vUpBack.SpeedRF = vUpBack.SpeedRB = Yasis;

			//LeftRight
			vLeftRight.SpeedLB = vLeftRight.SpeedRF = -Xasis;
			vLeftRight.SpeedLF = vLeftRight.SpeedRB = Xasis;

			//Turn
			vTurn.SpeedLF = vTurn.SpeedLB = Yaw;
			vTurn.SpeedRF = vTurn.SpeedRB = -Yaw;

			//Avg
			vTotal.SpeedLF = (vUpBack.SpeedLF + vLeftRight.SpeedLF + vTurn.SpeedLF);
			vTotal.SpeedLB = (vUpBack.SpeedLB + vLeftRight.SpeedLB + vTurn.SpeedLB);
			vTotal.SpeedRF = (vUpBack.SpeedRF + vLeftRight.SpeedRF + vTurn.SpeedRF);
			vTotal.SpeedRB = (vUpBack.SpeedRB + vLeftRight.SpeedRB + vTurn.SpeedRB);
		}
	}
task MecaDriver()
{
	while(true)
	{
		//MotorDriver(LeftFront,vTotal.SpeedLF, &MecaLF);
		//MotorDriver(LeftBack,vTotal.SpeedLB, &MecaLB);
		//MotorDriver(RightFront,vTotal.SpeedRF, &MecaRF);
		//MotorDriver(LeftBack,vTotal.SpeedRB, &MecaRB);
		motor[LeftFront] = vTotal.SpeedLF;
		motor[LeftBack] = vTotal.SpeedLB;
		motor[RightFront] = vTotal.SpeedRF;
		motor[RightBack] = vTotal.SpeedRB;
		motor[LeftCenter] = vexRT[Ch3] + vexRT[Ch1];
		motor[RightCenter] = vexRT[Ch3] - vexRT[Ch1];
		//wait1Msec(10);
	}
}
task main()
{
	startTask(GetCommand, kDefaultTaskPriority);
	startTask(MecaDriver, kDefaultTaskPriority);
	waitUntil(false);
}
