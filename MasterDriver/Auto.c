#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    HandCoder,      sensorPotentiometer)
#pragma config(Sensor, in2,    Xasic,          sensorAccelerometer)
#pragma config(Sensor, in3,    ExpanderBattery, sensorAnalog)
#pragma config(Sensor, in4,    Yasic,          sensorAccelerometer)
#pragma config(Sensor, dgtl1,  BoomLock,       sensorTouch)
#pragma config(Sensor, dgtl2,  KeyTouch,       sensorTouch)
#pragma config(Sensor, dgtl3,  HighHandTouch,  sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           GlMotor,       tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port3,           DtMotor,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           HighHandMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port5,           HandMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           BoomMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           BoomMotorAnother, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftWheel,     tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           RightWheel,    tmotorVex393_MC29, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port10,          Light,         tmotorVexFlashlight, openLoop, reversed)
#pragma config(DatalogSeries, 0, "LeftEncoder", Motors, MotorEncoder, port8, 10)
#pragma config(DatalogSeries, 1, "RightEncoder", Motors, MotorEncoder, port9, 10)
#pragma config(MotorPidSetting,  port8,  50, 9, 1000, 12, 10,  25, 80, 140)
#pragma config(MotorPidSetting,  port9,  50, 9, 1000, 12, 10,  25, 80, 140)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void FrontAuto5S()
{
	waitUntil(vexRT[Btn8U]);
	waitUntil(!vexRT[Btn8U]);
	resetMotorEncoder(LeftWheel);
	resetMotorEncoder(RightWheel);
	waitUntil(SensorValue[KeyTouch]);
	waitUntil(!SensorValue[KeyTouch]);
	clearTimer(T1);
	motor[BoomMotor] = motor[BoomMotorAnother] = 127;
	motor[HandMotor] = 50;
	waitUntil(SensorValue[BoomLock]);
	wait1Msec(500);
	motor[BoomMotor] = motor[BoomMotorAnother] = 0;
	setMotorTarget(LeftWheel, 0 ,70,false);
	setMotorTarget(RightWheel, 0,70,false);
	motor[HandMotor] = -35;
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	motor[LeftWheel]=motor[RightWheel] = 127;
	waitUntil(getMotorEncoder(LeftWheel) > 950|getMotorEncoder(RightWheel) > 950);
	motor[LeftWheel]=motor[RightWheel] = 0;
	motor[HandMotor] = 127;
	wait1Msec(750);
}
void FrontAuto15S()
{
	clearLCDLine(0);clearLCDLine(1);
	short VoltageErroe = -0;
	bLCDBacklight = true;
	//Go
	resetMotorEncoder(LeftWheel);
	resetMotorEncoder(RightWheel);
	waitUntil(SensorValue[KeyTouch] | nLCDButtons==2);
	clearTimer(T1);clearTimer(T2);
	short UpCode1 = 1000;
	setMotorTarget(LeftWheel, UpCode1,100 + VoltageErroe,false);
	setMotorTarget(RightWheel, UpCode1,100 + VoltageErroe,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	displayLCDNumber(0,0,time1[T1]);
	displayLCDNumber(0,10,getMotorEncoder(LeftWheel) - getMotorEncoder(RightWheel));
	//Back
	short BackPlace = 350;
	//short BackPlace = 0;
	setMotorTarget(LeftWheel, BackPlace,70 + VoltageErroe,false);
	setMotorTarget(RightWheel, BackPlace,70 + VoltageErroe,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	//Turn
	setMotorTarget(LeftWheel, getMotorEncoder(RightWheel)  + 340,50,true);
	setMotorTarget(RightWheel, getMotorEncoder(RightWheel) -340,50,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	motor[LeftWheel] = motor[RightWheel] = -50;
	wait1Msec(50);
	motor[LeftWheel] = motor[RightWheel] = 0;
	waitUntil(false);
	resetMotorEncoder(LeftWheel);
	resetMotorEncoder(RightWheel);
	motor[BoomMotor] = motor[BoomMotorAnother] = 127;
	motor[HandMotor] = 50;
	waitUntil(SensorValue[BoomLock]);
	wait1Msec(500);
	motor[HandMotor] = motor[BoomMotor] = motor[BoomMotorAnother] = 0;
	resetMotorEncoder(LeftWheel);
	resetMotorEncoder(RightWheel);
	setMotorTarget(LeftWheel, 500,50,false);
	setMotorTarget(RightWheel,500,50,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	}
void RearAuto5S()
{
	waitUntil(SensorValue[KeyTouch]);
	resetMotorEncoder(LeftWheel);
	resetMotorEncoder(RightWheel);
	short Code = 1100;
	setMotorTarget(LeftWheel, Code ,110,false);
	setMotorTarget(RightWheel,Code,110,false);
	motor[GlMotor] = -127;
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
}
void RearAuto10S()
{
	bLCDBacklight = true;
	waitUntil(SensorValue[KeyTouch]);
	clearTimer(T1);
	resetMotorEncoder(LeftWheel);
	resetMotorEncoder(RightWheel);
	short Code = 1000;
	setMotorTarget(LeftWheel, Code ,110,false);
	setMotorTarget(RightWheel,Code,110,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	resetMotorEncoder(LeftWheel);
	resetMotorEncoder(RightWheel);
	setMotorTarget(LeftWheel,  340  ,70,false);
	setMotorTarget(RightWheel,-340  ,70,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	motor[LeftWheel]=motor[RightWheel] = 127;
	wait1Msec(1500);
	motor[LeftWheel]=motor[RightWheel] = 0;
	displayLCDNumber(0,0,time1[T1]);
}
