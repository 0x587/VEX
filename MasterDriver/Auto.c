#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    HandCoder,      sensorPotentiometer)
#pragma config(Sensor, in2,    Xasic,          sensorAccelerometer)
#pragma config(Sensor, in3,    ExpanderBattery, sensorAnalog)
#pragma config(Sensor, in4,    Yasic,          sensorAccelerometer)
#pragma config(Sensor, dgtl1,  BoomLock,       sensorTouch)
#pragma config(Sensor, dgtl2,  KeyTouch,       sensorTouch)
#pragma config(Sensor, dgtl3,  HighHandTouch,  sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           GlMotor,       tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port3,           DtMotor,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           HighHandMotor, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port5,           HandMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           BoomMotor,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           BoomMotorAnother, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftWheel,     tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           RightWheel,    tmotorVex393_MC29, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port10,          Light,         tmotorVexFlashlight, openLoop, reversed)
#pragma config(MotorPidSetting,  port8,  50, 9, 1000, 10, 10,   28, 70, 120)
#pragma config(MotorPidSetting,  port9,  50, 9, 1000, 10, 10,   27, 70, 120)
#pragma config(DatalogSeries, 0, "LeftEncoder", Motors, MotorEncoder, port8, 10)
#pragma config(DatalogSeries, 1, "RightEncoder", Motors, MotorEncoder, port9, 10)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void GetBall()
{
	motor[LeftWheel] = motor[RightWheel] = 50;
	waitUntil(getMotorEncoder(LeftWheel) > 200 | getMotorEncoder(RightWheel) > 200);
	motor[LeftWheel] = motor[RightWheel] = 100;
	waitUntil(getMotorEncoder(LeftWheel) > 500 | getMotorEncoder(RightWheel) > 500);
	motor[GlMotor] = 127;
	waitUntil(getMotorEncoder(LeftWheel) > 1000 | getMotorEncoder(RightWheel) > 1000);
	motor[LeftWheel] = motor[RightWheel] = 35;
	waitUntil(getMotorEncoder(LeftWheel) > 1450 | getMotorEncoder(RightWheel) > 1450);
	motor[LeftWheel] = motor[RightWheel] = -50;
	waitUntil(getMotorEncoder(LeftWheel) > 1200 | getMotorEncoder(RightWheel) > 1200);
	motor[LeftWheel] = motor[RightWheel] = -75;
	waitUntil(getMotorEncoder(LeftWheel) > 1000 | getMotorEncoder(RightWheel) > 1000);
	motor[LeftWheel] = motor[RightWheel] = -100;
	waitUntil(getMotorEncoder(LeftWheel) > 800 | getMotorEncoder(RightWheel) > 800);
	motor[LeftWheel] = motor[RightWheel] = -127;
	waitUntil(getMotorEncoder(LeftWheel) < 600 | getMotorEncoder(RightWheel) < 600);
	motor[GlMotor] = 0;
	waitUntil(getMotorEncoder(LeftWheel) < 500 | getMotorEncoder(RightWheel) < 500);
	motor[LeftWheel] = motor[RightWheel] = -75;
	waitUntil(getMotorEncoder(LeftWheel) < 100 | getMotorEncoder(RightWheel) < 60);
	motor[LeftWheel] = motor[RightWheel] = -25;
	waitUntil(getMotorEncoder(LeftWheel) < 50 | getMotorEncoder(RightWheel) < 40);
	wait1Msec(500);
	motor[LeftWheel] = motor[RightWheel] = 0;
	motor[GlMotor] = 0;
}
void BoomOne()
{
	while(SensorValue[HandCoder] < 1200)
	{
		motor[HandMotor] = 50;
	}
	motor[HandMotor] = 0;
	motor[BoomMotor]=motor[BoomMotorAnother]=127;
	waitUntil(SensorValue[BoomLock]);
	wait1Msec(325);
	motor[BoomMotor]=motor[BoomMotorAnother]=0;
}
task main()
{
	clearTimer(T1);clearTimer(T2);
	clearLCDLine(0);clearLCDLine(1);
	short VoltageErroe = -0;
	bLCDBacklight = true;
	//Go
	resetMotorEncoder(LeftWheel);
	resetMotorEncoder(RightWheel);
	//waitUntil(SensorValue[KeyTouch] | nLCDButtons==2);
	short UpCode1 = 1000;
	setMotorTarget(LeftWheel, UpCode1,100 + VoltageErroe,false);
	setMotorTarget(RightWheel, UpCode1,100 + VoltageErroe,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	displayLCDNumber(0,0,time1[T1]);
	displayLCDNumber(0,10,getMotorEncoder(LeftWheel) - getMotorEncoder(RightWheel));
	//Back

	short BackPlace = 550;
	//short BackPlace = 0;
	setMotorTarget(LeftWheel, BackPlace,75 + VoltageErroe,false);
	setMotorTarget(RightWheel, BackPlace,75 + VoltageErroe,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	//stopAllTasks();
	displayLCDNumber(1,0,time1[T2]);
	displayLCDNumber(1,10,getMotorEncoder(LeftWheel) - getMotorEncoder(RightWheel));
	//Turn
	//resetMotorEncoder(LeftWheel);
	//resetMotorEncoder(RightWheel);
	setMotorTarget(RightWheel, getMotorEncoder(RightWheel) -637,80,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	//waitUntil(vexRT[Btn8U]);
	//resetMotorEncoder(LeftWheel);
	//resetMotorEncoder(RightWheel);
	stopAllTasks();
	setMotorTarget(LeftWheel, 64,getMotorEncoder(LeftWheel) + 50,false);
	setMotorTarget(RightWheel,64,getMotorEncoder(RightWheel) + 50,false);
	waitUntil(getMotorTargetCompleted(LeftWheel)& getMotorTargetCompleted(RightWheel));
	wait1Msec(1000);
}
