#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           Light,         tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           DtMotor,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           GlMotor,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port5,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           BoomMotor1,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port7,           BoomMotor2,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftWheel,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           RightWheel,    tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Joysticks.c"
#include "Struct.c"
#include "Motor.c"
//Global Four Driver Motor
DriverMotorValue DriverMotor[5];
///////////////////////////////
task DriverMotorCommand()
{
	float DefKp = 0.215;
	float DefKd = 0.0;

	//Set Motor Port
	DriverMotor[0].Port = RightWheel;
	DriverMotor[1].Port = LeftWheel;
	// Set PID Value
	for(short i = 0;i<4;i++)
	{
		DriverMotor[i].Kp = DefKp;
		DriverMotor[i].Kd = DefKd;
	}
	while(true)
	{
		UpDateTargetSpeed(DriverMotor);
		//UpDateSpeed(DriverMotor);//Spend 5ms
		//for(short i = 0;i<5;i++)
		//{
		//	}else{
		//		if(DriverMotor[i].Speed != 0)
		//		{
		//			DriverMotor[i].Force = (motor[DriverMotor[i].Port] / DriverMotor[i].Speed)*100;
		//		}
		//		short Error = DriverMotor[i].TargetSpeed - DriverMotor[i].Speed;
		//		DriverMotor[i].dValue += (Error - DriverMotor[i].LastErroe);
		//		DriverMotor[i].LastErroe = Error;
		//		//if(abs(motor[DriverMotor[i].Port] + ((Error * DriverMotor[i].Kp)+(DriverMotor[i].dValue * DriverMotor[i].Kd)))>15)
		//		//{motor[DriverMotor[i].Port] += ((Error * DriverMotor[i].Kp)+(DriverMotor[i].dValue * DriverMotor[i].Kd));}
		//		//else{motor[DriverMotor[i].Port] = 0;}
		//		motor[DriverMotor[i].Port] = DriverMotor[i].TargetSpeed;
		//	}
		//}
		for(short i = 0;i<2;i++)
		{
			motor[DriverMotor[i].Port] = DriverMotor[i].TargetSpeed;
		}
	}
}
task Flash()
{
	bool isLight;
	while(true)
	{
		//Update isLight
		if(vexRT[Btn5U])
		{
			isLight=!isLight;
			wait1Msec(200);
		}
		//Boom Run
		if(vexRT[Btn8R] & vexRT[Btn5D])
		{
			short BoomT;
			BoomT = getMotorVelocity(BoomMotor1);
			clearTimer(T1);
			motor[Light]=motor[Light]=127;
			waitUntil(time1[T1]>BoomT);
			clearTimer(T1);
			motor[Light]=motor[Light]=0;
			waitUntil(time1[T1]>BoomT);
		}
	}
}
task OtherDriver()
{
	while(true)
	{
		if (vexRT[Btn8U]) //DT com
		{
			if (vexRT[Btn5U]){motor[DtMotor] = 127;}
			else if (vexRT[Btn5D]){motor[DtMotor] = -127;}
			else{motor[DtMotor] = 0;}
		}
		else if (vexRT[Btn8D]) // GL com
		{
			if (vexRT[Btn5U]){motor[GlMotor] = 127;}
			else if (vexRT[Btn5D]){motor[GlMotor] = -127;}
			else if (vexRT[Btn7D]){motor[GlMotor] = 0;}
		}
		else if (vexRT[Btn8R]) // Boom com
		{
			if (vexRT[Btn5U]){motor[BoomMotor1] = motor[BoomMotor2] = 127;}
			else if (vexRT[Btn5D]){motor[BoomMotor1] = motor[BoomMotor2] = -127;}
			else{motor[BoomMotor1] = motor[BoomMotor2] = 0;}
		}
		else
		{
			motor[BoomMotor1] = motor[BoomMotor2] = 0;
			motor[DtMotor] = 0;
		}
	}
}
task main()
{
	startTask(Flash, kDefaultTaskPriority);
	startTask(DriverMotorCommand, kDefaultTaskPriority);
	startTask(OtherDriver, kDefaultTaskPriority);
	waitUntil(false);
}
