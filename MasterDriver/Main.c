#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  BoomLock,       sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           GlMotor,       tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port3,           DtMotor,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           GlMotor,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           BoomMotor,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port7,           BoomMotorAnother, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port8,           LeftWheel,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           RightWheel,    tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          Light,         tmotorVexFlashlight, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Joysticks.c"
#include "Struct.c"
#include "Motor.c"
//Global Four Driver Motor
command Command;
DriverMotorValue DriverMotorList[2];

///////////////////////////////
task DriverMotorConfig()
{
	DriverMotorList[0].Port = LeftWheel;
	DriverMotorList[1].Port = RightWheel;
	slaveMotor(BoomMotorAnother, BoomMotor);
}
task DriverMotor()
{
	while (true)
	{
		UpDateCommand(Command);
		UpDateMotorState(DriverMotorList);
		DriverMotorList[0].TargetPower = Command.LeftWheelPower;
		DriverMotorList[1].TargetPower = Command.RightWheelPower;
		DriverMotorDo(DriverMotorList);
	}
}
task Flash()
{
	bool isLight;
	while(true)
	{
		//Update isLight
		if(vexRT[Btn5U])
		{
			isLight=!isLight;
			wait1Msec(200);
		}
		//Boom Run
		if(vexRT[Btn8R] & vexRT[Btn5D])
		{
			short BoomT;
			BoomT = getMotorVelocity(BoomMotor);
			clearTimer(T1);
			motor[Light]=motor[Light]=127;
			waitUntil(time1[T1]>BoomT);
			clearTimer(T1);
			motor[Light]=motor[Light]=0;
			waitUntil(time1[T1]>BoomT);
		}
	}
}
task OtherDriver()
{
	bool LockReady;
	bool isLocking;
	bool CanShoot;
	while(true)
	{
		if (vexRT[Btn8U]) //DT com
		{
			if (vexRT[Btn5U]){motor[DtMotor] = 127;}
			else if (vexRT[Btn5D]){motor[DtMotor] = -127;}
			else{motor[DtMotor] = 0;}
		}
		else if (vexRT[Btn8D]) // GL com
		{
			if (vexRT[Btn5U]){motor[GlMotor] = 127;}
			else if (vexRT[Btn5D]){motor[GlMotor] = -127;}
			else if (vexRT[Btn7D]){motor[GlMotor] = 0;}
		}
		else if (vexRT[Btn8R]) // Boom com
		{
			if(vexRT[Btn7D])
			{
				LockReady = !LockReady;
				waitUntil(!vexRT[Btn7D]);
			}
			if(vexRT[Btn7U])
			{
				CanShoot = !CanShoot;
				waitUntil(!vexRT[Btn7U]);
			}
			if( !LockReady )
			{
				if (vexRT[Btn5U]){motor[BoomMotor] = 127;}
				else if (vexRT[Btn5D]){motor[BoomMotor] = -127;}
				else{motor[BoomMotor] = 0;}
			}
		}
		else
		{
			if ( !LockReady )
			{
				motor[BoomMotor] = 0;
			}
			motor[DtMotor] = 0;
		}
		if(LockReady)
		{
			while(!SensorValue[BoomLock])
			{
				motor[BoomMotor] = 127;
			}
			motor[BoomMotor] = 50;//Lock Power
			isLocking = true;
		}else{
			isLocking = false;
		}
		if(CanShoot)
		{
			if(isLocking)
			{
				motor[BoomMotor] = 127;
				waitUntil( !SensorValue[BoomLock] );
				CanShoot = isLocking = false;
			}
		}
	}
}
task Auto(){}
task main()
{
	bool DoAuto = false;
	//Config
	startTask(DriverMotorConfig,kDefaultTaskPriority);
	//Wait Start Button
	waitUntil(!true);
	if (DoAuto)
	{
		short AutoTime = 15 * 1000;
		clearTimer(T1);
		startTask(Auto, kDefaultTaskPriority); //Do Auto Part
		waitUntil(time1[T1] > AutoTime);
		stopTask(Auto);
	}
	
	
	//Start Manual Part
	startTask(Flash,            kDefaultTaskPriority);
	startTask(DriverMotor,      kDefaultTaskPriority);
	startTask(OtherDriver,      kDefaultTaskPriority);
	//startTask(OutPutBoom , kDefaultTaskPriority);
	waitUntil(false);
}
