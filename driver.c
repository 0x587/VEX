#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  LeftCenterEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  LeftAroundEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  RightCenterEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  RightAroundEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           RightWheel,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LeftWheel,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
struct command{
	short LeftMotor;
	short RightMotor;
	short Hand;
	short GL;
	short DT;
	short DP;
	bool RL;
	bool LL;
};
struct state{
	short up;
	short turn;
	short LeftCenPal;
	short LeftAroPal;
	short RightCenPal;
	short RightAroPal;
	short LeftPower;
	short RightPower;
	int Range;
	int HandState;
};
struct Pid
{
	float Kp;
	float Ki;
	float Kd;
	int Error;
	int iValue;
	int dValue;
	int LastError;
};

// global struct
command Command;
state State;
Pid PID;
//

void GetPalstance()
{
	// return Palstance rad/s
	int StartLC,StartLA, StartRC, StartRA;
	StartLC = SensorValue[LeftCenterEncode];
	StartLA = SensorValue[LeftAroundEncode];
	StartRC = SensorValue[RightCenterEncode];
	StartRA = SensorValue[RightAroundEncode];
	wait1Msec(5);
	State.LeftCenPal = (SensorValue[LeftCenterEncode] - StartLC) / 5 * 1000;
	State.LeftAroPal = (SensorValue[LeftCenterEncode] - StartLC) / 5 * 1000;
	State.RightCenPal = (SensorValue[RightCenterEncode] - StartRC) / 5 * 1000;
	State.RightAroPal = (SensorValue[RightCenterEncode] - StartRC) / 5 * 1000;
}
task PidController()
{
	short P, I, D;
	while(true)
	{
		GetPalstance();
		int Error = PID.Error;
		P = Error * PID.Kp;

		PID.iValue += Error;
		I = iValue;
		PID.iValue += Error - LastError;
		D = dValue;
		PID.LastError = Error;
	}
}
task Do()
{
	while(true)
	{
		if(abs(Command.RightMotor)>20){motor[RightWheel]=Command.RightMotor;}
		else{motor[RightWheel]=0;}
		if(abs(Command.LeftMotor)>20){motor[LeftWheel]=Command.LeftMotor;}
		else{motor[LeftWheel]=0;}
	}
}
task main()
{
	bLCDBacklight = true;
	startTask(Do, kDefaultTaskPriority);
	startTask(PidController, kDefaultTaskPriority);
}
