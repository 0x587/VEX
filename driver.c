#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  LeftCenterEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  LeftAroundEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  RightCenterEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  RightAroundEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           RightWheel,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LeftWheel,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

struct Command{
	short LeftMotor;
	short RightMotor;
	short Hand;
	short GL;
	short DT;
	short DP;
	bool RL;
	bool LL;
};
struct State{
	short up;
	short turn;
	short LeftCenPal;
	short LeftAroPal;
	short RightCenPal;
	short RightAroPal;
	short LeftPower;
	short RightPower;
	int Range;
	int HandState;
};
// global
Command command;
State state;

void GetPalstance()
{
	// return Palstance rad/s
	int StartLC,StartLA, StartRC, StartRA;
	StartLC = SensorValue[LeftCenterEncode];
	StartLA = SensorValue[LeftAroundEncode];
	StartRC = SensorValue[RightCenterEncode];
	StartRA = SensorValue[RightAroundEncode];
	wait1Msec(5);
	state.LeftCenPal = (SensorValue[LeftCenterEncode] - StartLC) / 5 * 1000;
	state.LeftAroPal = (SensorValue[LeftCenterEncode] - StartLC) / 5 * 1000;
	state.RightCenPal = (SensorValue[RightCenterEncode] - StartRC) / 5 * 1000;
	state.RightAroPal = (SensorValue[RightCenterEncode] - StartRC) / 5 * 1000;
}

task Do()
{
	while(true)
	{
		if(abs(command.RightMotor)>20){motor[RightWheel]=command.RightMotor;}
		else{motor[RightWheel]=0;}
		if(abs(command.LeftMotor)>20){motor[LeftWheel]=command.LeftMotor;}
		else{motor[LeftWheel]=0;}
	}
}
task main()
{
	bLCDBacklight = true;
	startTask(Do, kDefaultTaskPriority);
}
