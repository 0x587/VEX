#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LeftFront,     tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port3,           LeftBack,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port4,           RightFront,    tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_3)
#pragma config(Motor,  port5,           RightBack,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
short DataHandling(short data)
{
	int temp = (data*100/127);
	short back;
	if (temp > 0)
	{
		if (temp < 10){temp = 0;}
		else if (temp < 80)
		{
			temp = (temp - 10) / 2;
			}else{
			temp = (13 * temp) / 4 - 225;
		}
	}
	else
	{
		if (temp > -10){temp = 0;}
		else if (temp > -80)
		{
			temp = (temp + 10) / 2;
		}else
		{
			temp = (13 * temp) / 4 + 225;
		}

	}
	back = temp*127/100;
	return back;
}

void MotorSpeedPID(tMotor MotorPort ,short TargetSpeed)
{
	float Kp =0.75,
	K_SpeedToPower = 100/160;
	short NowSpeed = getMotorVelocity(MotorPort);
	short Error = TargetSpeed - NowSpeed;
	motor[MotorPort] += Error * Kp * K_SpeedToPower;
}
struct MotorPidValue
{
	float Kp;
	float Kd;
	int LastErroe;
	int dValue;
}
struct ActionVector
{
	short SpeedLF;
	short SpeedLB;
	short SpeedRF;
	short SpeedRB;
};
ActionVector vUpBack, vLeftRight, vTurn, vAvg;
short Xasis,Yasis,Yaw;
task main()
{
	Xasis = DataHandling(vexRT[Ch4]);
	Yasis = DataHandling(vexRT[Ch3]);
	Yaw = DataHandling(vexRT[Ch1]);

	// UpBack
	vUpBack.SpeedLF = vUpBack.SpeedLB = vUpBack.SpeedRF = vUpBack.SpeedRB = Xasis;

	//LeftRight
	vLeftRight.SpeedLB = vLeftRight.SpeedRF = -Yasis;
	vLeftRight.SpeedLF = vLeftRight.SpeedRB = Yasis;

	//Turn
	vTurn.SpeedLF = vTurn.SpeedLB = vTurn;
	vTurn.SpeedRF = vTurn.SpeedRB = -vTurn;

	//Avg
	vAvg.SpeedLF = (vUpBack.SpeedLF+vLeftRight.SpeedLF+vTurn.SpeedLF)/3;
	vAvg.SpeedLB = (vUpBack.SpeedLB + vLeftRight.SpeedLB + vTurn.SpeedLB) / 3;
	vAvg.SpeedRF = (vUpBack.SpeedRF + vLeftRight.SpeedRF + vTurn.SpeedRF) / 3;
	vAvg.SpeedRB = (vUpBack.SpeedRB + vLeftRight.SpeedRB + vTurn.SpeedRB) / 3;

	//DO
	MotorSpeedPID(LeftFront, vAvg.SpeedLF);
	MotorSpeedPID(LeftBack, vAvg.SpeedLB);
	MotorSpeedPID(RightFront, vAvg.SpeedRF);
	MotorSpeedPID(LeftBack, vAvg.SpeedRB);
	motor[port1] =1;
}
