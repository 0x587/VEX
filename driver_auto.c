#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  LeftCenterEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  LeftAroundEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  RightCenterEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  RightAroundEncode, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           RightWheel,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           LeftWheel,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
struct state{
	short up;
	short turn;
	short LeftCenPal;
	short LeftAroPal;
	short RightCenPal;
	short RightAroPal;
	int LeftCenCode;
	int LeftAroCode;
	int RightCenCode;
	int RightAroCode;
	short LeftPower;
	short RightPower;
	int Range;
	int HandState;
};
struct Pid
{
	float Kp;
	float Ki;
	float Kd;
	int pValue;
	int iValue;
	int dValue;
	int LastError;
	short out_max;
	short out_min;
};

//global struct
state State;
Pid DriverPID;
//

void ReadDriverSensor()
{
	// return Palstance rad/s
	int StartLC,StartLA, StartRC, StartRA;
	StartLC = SensorValue[LeftCenterEncode];
	StartLA = SensorValue[LeftAroundEncode];
	StartRC = SensorValue[RightCenterEncode];
	StartRA = SensorValue[RightAroundEncode];
	wait1Msec(5);
	State.LeftCenCode = SensorValue[LeftCenterEncode];
	State.LeftAroCode = SensorValue[LeftAroundEncode];
	State.RightCenCode = SensorValue[RightCenterEncode];
	State.RightAroCode = SensorValue[RightAroundEncode];
	State.LeftCenPal = (State.LeftCenCode - StartLC) / 5 * 1000;
	State.LeftAroPal = (State.LeftAroCode - StartLC) / 5 * 1000;
	State.RightCenPal = (State.RightCenCode - StartRC) / 5 * 1000;
	State.RightAroPal = (State.RightAroCode - StartRC) / 5 * 1000;
}
int PidOperation( Pid *pPID , int Error)
{
	int P, I, D, Out;
	pPID -> pValue = Error * pPID -> Kp;
	P = pPID->pValue;

	pPID->iValue += pPID -> Ki * Error;
	I = pPID -> iValue;

	pPID->dValue += pPID->Kd * (pPID->LastError - Error);
	D = pPID -> dValue;

	pPID -> LastError = Error;
	Out = P + I +D;
	if (Out < pPID -> out_min) {Out = pPID->out_min;}
	else if (Out > pPID->out_max){Out = pPID -> out_max;}
	return Out;
}
task main()
{
	bLCDBacklight = true;
	int tar = 1000;
	int LE, RE;
	short LeftPID,RightPID;
	DriverPID.Kp = 1;
	DriverPID.Ki = 1;
	DriverPID.Kd = 1;
	while(true)
	{
		ReadDriverSensor();
		LE = tar - State.LeftAroCode;
		RE = tar - State.RightAroCode;
		LeftPID = PidOperation(&DriverPID, LE);
		RightPID = PidOperation(&DriverPID, RE);
		motor[LeftWheel] = LeftPID;
		motor[RightWheel] = RightPID;
	}
}
